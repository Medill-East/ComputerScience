% Copyright (c) 2017-2018, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons Attribution-NoDerivatives 4.0
% International License (see LICENSE file or visit
% <http://creativecommons.org/licenses/by-nc-nd/4.0/> for details).

\chapter{Constraint Model}
\labelChapter{constraint-model}

This chapter introduces the \gls{constraint model} for \gls{universal
  instruction selection}.
%
We build the \glsshort{constraint model} by integrating one task a time.
%
To this end,
\refSectionRange{modeling-global-instruction-selection}{modeling-block-ordering}
describe the \glspl{variable} and \glspl{constraint} for modeling
\gls{global.is} \gls{instruction selection}, \gls{global code motion}, \gls{data
  copying}, \gls{value reuse}, and \gls{block ordering}, respectively.
%
We then add the \gls{objective function}, which is described in
\refSection{cm-objective-function}.
%
With all crucial components in place, we discuss the limitations of the
\glsshort{constraint model} in \refSection{cm-limitations}.
%
Lastly, a summary is given in \refSection{model-summary}.


\section{Modeling Global Instruction Selection}
\labelSection{modeling-global-instruction-selection}

Modeling \gls{global.is} \gls{instruction selection} entails that all
\glspl{operation} are \gls{cover}[ed] and all \glspl{datum} are
\gls{define.d}[d].
%
This could, however, lead to situations resulting in cyclic data dependencies,
which must be prevented.


\subsection{Covering Operations and Defining Data}

In \gls{global.is}[ \gls{instruction selection}], a set of \glspl{match} must be
selected such that every \gls{operation} in a given \gls{UF graph} is covered.
%
We model \gls{exact.c} \gls{cover}[age] since it enables use of many solving
techniques that are essential for curbing solving time and increasing
scalability.
%
Similarly, we model that every value and state must be produced by exactly one
selected \gls{match}.
%
If a \gls!{datum}~$d$ denotes either a \glsshort{state node} or \gls{value node}
in the \gls{UF graph}, then we say that a \gls{match}~$m$ \gls!{define.d}[s] $d$
if there exists an \gls{inbound.e} \glsshort{state-flow edge} or \gls{data-flow
  edge} to $d$ in the \gls{UP graph} from which $m$ is derived.
%
Likewise, $m$ \gls!{use.d}[s] $d$ if there exists an \gls{outbound.e}
\glsshort{state-flow edge} or \gls{data-flow edge} to $d$ in the \gls{UP graph}.


\paragraph{Variables}

Given a \gls{UF graph}~$\mUFGraph$ and a set~$\mMatchSet$ of \glspl{match}, the
set of \glspl{variable} \mbox{$\mVar{sel}[m] \in \mSet{0, 1}$} models whether
\gls{match}~\mbox{$m \in \mMatchSet$} is selected.
%
Hence $m$ is selected if \mbox{$\mVar{sel}[m] = 1$}, abbreviated
$\mVar{sel}[m]$, and not selected if \mbox{$\mVar{sel}[m] = 0$}, abbreviated
\mbox{$\mNot\mVar{sel}[m]$}.

The set of \glspl{variable} \mbox{$\mVar{omatch}[o] \in \mMatchSet[o]$} models
which selected \gls{match} covers \gls{operation}~\mbox{$o \in
  \mOpSet$\hspace{-1pt},} where $\mOpSet$ denotes the set of \glspl{operation}
in $\mUFGraph$ and \mbox{$\mMatchSet[o] \subseteq \mMatchSet$} denotes the set
of \glspl{match} covering~\mbox{$o$\hspace{-.8pt}.}
%
Similarly, the set of \glspl{variable} \mbox{$\mVar{dmatch}[d] \in
  \mMatchSet[d]$} models which selected \gls{match} \gls{define.d}[s]
\gls{datum}~\mbox{$d \in \mDataSet$\hspace{-1.5pt},} where $\mDataSet$ denotes
the set of \glspl{datum} in $\mUFGraph$ and \mbox{$\mMatchSet[d] \subseteq
  \mMatchSet$} denotes the set of \glspl{match}
\glsshort{define.d}[ing]~\mbox{$d$\hspace{-.8pt}.}


\paragraph{Constraints}

The \gls{constraint} that every \gls{operation} must be covered is modeled as
%
\begin{equation}
  \forall o \in \mOpSet \hspace{-1pt},
  \forall m \in \mMatchSet[o] :
  \mVar{omatch}[o] = m \mEq \mVar{sel}[m].
  \labelEquation{operation-coverage}
\end{equation}
%
This \gls{constraint} gives equally strong \gls{propagation} as
\refEquation{pattern-selection-using-gcc}, making it redundant to add the latter
as an \gls{implied.c} \gls{constraint} to the \glsshort{constraint model}.

Likewise, the \gls{constraint} that every \gls{datum} must be \gls{define.d}[d]
is modeled as
%
\begin{equation}
  \forall d \in \mDataSet \hspace{-1.5pt},
  \forall m \in \mMatchSet[d] :
  \mVar{dmatch}[d] = m \mEq \mVar{sel}[m].
  \labelEquation{data-definitions}
\end{equation}
%
We assume that the \gls{pattern set} has been extended with a special
\gls!{null-def pattern}, with \gls{graph} structure \mbox{$\mEdge{b}{d}$} where
$b$ is a \gls{entry block} and $d$ is a \gls{datum}, that defines $d$ at zero
cost.
%
This \gls{pattern} is needed for defining \glspl{datum} representing
\gls{function} arguments and constants since these are not produced by any
\gls{operation}.


\subsection{Preventing Cyclic Data Dependencies}
\labelSection{forbidding-cyclic-data-dependencies}

In certain cases, selecting \glspl{match} of \glspl{instruction} that produce
multiple results could lead to cyclic data dependencies~\cite{EbnerEtAl:2008}.
%
For example, many modern processors provide memory \glspl{instruction} that load
or store a value while also incrementing or decrementing the address.
%
An example of such a situation is given in \refFigure{cyclic-data-deps-example}.
%
\begin{filecontents*}{cyclic-data-deps-example-ir.c}
$\ldots$
$\irAssign{\irVar{p}[2]}{\irAdd{\irVar{p}[1]}{\irVar{4}}}$
$\irStore{\irVar{q}[1]}{\irVar{p}[2]}$
$\irAssign{\irVar{q}[2]}{\irAdd{\irVar{q}[1]}{\irVar{4}}}$
$\irStore{\irVar{p}[1]}{\irVar{q}[2]}$
\end{filecontents*}%
%
\begin{figure}
  \subcaptionbox{IR\labelFigure{cyclic-data-deps-example-ir}}%
                {%
                  \begin{lstpage}{22mm}%
                    \lstinputlisting[language=c,mathescape]%
                                    {cyclic-data-deps-example-ir.c}%
                  \end{lstpage}%
                }%
  \hfill%
  \subcaptionbox{%
                  UF graph, covered by two matches derived from an
                  auto-increment store instruction.
                  %
                  For brevity, the state nodes are not included%
                  \labelFigure{cyclic-data-deps-example-uf-graph}%
                }%
                [62mm]%
                {%
                  \input{%
                    figures/constraint-model/cyclic-data-deps-example-uf-graph%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  Dependency graph%
                  \labelFigure{cyclic-data-deps-example-dep-graph}%
                }%
                [32mm]%
                {%
                  \input{%
                    figures/constraint-model/cyclic-data-deps-example-dep-graph%
                  }%
                }

  \caption{Example of cyclic data dependencies}%
  \labelFigure{cyclic-data-deps-example}%
\end{figure}
%
If both \glspl{match} are selected, then either value~\irVar*{p}[2] or
value~\irVar*{q}[2] will be \gls{use.d}[d] before it is available (depending on
the instruction order), thus resulting in incorrect code.
%
Such combinations, which could involve more than two \glspl{match}, must
therefore be identified and prevented.

We detect such combinations by first constructing a \gls!{dependency graph},
where each \gls{node} represents a \gls{match} and each
\gls{edge}~$\mEdge{n}{m}$ indicates that \gls{match}~$m$ \gls{use.d}[s]
\glspl{datum} produced by \gls{match}~\mbox{$n$\hspace{-.8pt}.}
%
\Glspl{phi-match} are not taken into consideration as they do not incur true
cyclic data dependencies.
%
A \gls{cycle} in the \gls{dependency graph} corresponds a combination of
\glspl{match} which will lead to a cyclic data dependency if all \glspl{match}
are selected.
%
For each \gls{cycle} in the \gls{dependency graph}, we add a \gls{constraint} to
the \gls{constraint model} that forbids selection of all \glspl{match} appearing
in the \gls{cycle}.
%
The \glspl{cycle} can be found using any \gls{cycle}-finding algorithm (see for
example~\cite{Johnson:1975}).


\paragraph{Constraints}

Given a set~\mbox{$\mForbiddenCombSet \subseteq \mPowerset{\mMatchSet}$} of
\glspl{cycle} found for the \gls{dependency graph} built from a \gls{UF graph}
and \gls{match set}~$\mMatchSet$, the \gls{constraint} forbidding cyclic data
dependencies is modeled as
%
\begin{equation}
  \forall f \in \mForbiddenCombSet :
  \sum_{\mathclap{m \in f}} \mVar{sel}[m] < \mCard{f}.
  \labelEquation{cyclic-data-deps}
\end{equation}


\section{Modeling Global Code Motion}
\labelSection{modeling-global-code-motion}

The \gls{global code motion} problem entails that \glspl{datum} are placed in
\glspl{block} such that each definition of a \gls{datum}~$d$ precedes all
\gls{use.d}[s] of~\mbox{$d$\hspace{-.8pt}.}
%
This condition can be expressed in terms of \gls{block} dominance.
%
Given a \gls{function}~$f$\!, a \gls{block}~$b$ in $f$ \gls!{dominate.b}[s]
another \gls{block}~$c$ in $f$ if $b$ appears on every control-flow path from
$f$'s \gls{entry block} to $c$.
%
By definition, a \gls{block} always \gls{dominate.b}[s] itself (see
\refFigure{block-dominance-example} for an example).

\begin{figure}
  \mbox{}%
  \hfill%
  \subcaptionbox{Control-flow graph\labelFigure{block-dominance-example-cfg}}%
                [34mm]%
                {%
                  \input{%
                    figures/constraint-model/block-dominance-example%
                  }%
                }%
  \hfill%
  \subcaptionbox{Dominance\labelFigure{block-dominance-example-doms}}%
                {%
                  \figureFont\figureFontSize%
                  \begin{tabular}{cc}
                    \toprule
                      \tabhead block
                    & \tabhead dominates\\
                    \midrule
                      \irBlock{entry}
                    & $\mSet{\irBlock{entry}, \irBlock{A}, \irBlock{B},
                        \irBlock{C}, \irBlock{D}, \irBlock{E}}$\\
                      \irBlock{A}
                    & $\mSet{\irBlock{A}, \irBlock{B}, \irBlock{C},
                        \irBlock{D}}$\\
                      \irBlock{B}
                    & $\mSet{\irBlock{B}}$\\
                      \irBlock{C}
                    & $\mSet{\irBlock{C}}$\\
                      \irBlock{D}
                    & $\mSet{\irBlock{D}}$\\
                      \irBlock{E}
                    & $\mSet{\irBlock{E}}$\\
                    \bottomrule
                  \end{tabular}%
                }%
  \hfill%
  \mbox{}

  \caption{Example of block dominance}
  \labelFigure{block-dominance-example}
\end{figure}

Hence a placement of \glspl{match} into \glspl{block} is a \gls{solution} to the
\gls{global code motion} problem if each \gls{datum}~$d$ is \gls{define.d}[d] by
some selected \gls{match} placed in a \gls{block}~\mbox{$b$\hspace{-1pt},} and
every non-\gls{phi-match} \glsshort{use.d}[ing] $d$ is placed in a \gls{block}
\gls{dominate.b}[d] by~\mbox{$b$\hspace{-1pt}.}
%
The \glspl{phi-match} must be excluded since, due to the \glspl{definition
  edge}, at least one \gls{datum} used by such \glspl{match} must be
\gls{define.d}[d] in a \gls{block} that does not \gls{dominate.b} the
\gls{block} wherein the \gls{phi-match} must be placed.


\paragraph{Variables}

The set of \glspl{variable} \mbox{$\mVar{oplace}[o] \in \mBlockSet$} models in
which \gls{block} \gls{operation}~$o$ is placed, where $\mBlockSet$ denotes the
set of \glspl{block} in $\mUFGraph$.
%
Likewise, the set of \glspl{variable} \mbox{$\mVar{dplace}[d] \in \mBlockSet$}
models in which \gls{block} the definition of \gls{datum}~$d$ is placed.


\paragraph{Constraints}

Intuitively, all \glspl{operation} covered by a \gls{match}~$m$ must be placed
in the same \gls{block} wherein $m$ itself is placed.
%
Hence, if \mbox{$\mCovers(m) \subseteq \mOpSet$} denotes the set of
\glspl{operation} covered by \gls{match}~\mbox{$m$\hspace{-.8pt},} then this
\gls{constraint} is modeled as
%
\begin{equation}
  \forall m \in \mMatchSet,
  \forall o_1\hspace{-1pt}, o_2 \in \mCovers(m) :
  \mVar{sel}[m] \mImp \mVar{oplace}[o_1] = \mVar{oplace}[o_2].
  \labelEquation{operation-placement}
\end{equation}
%
This also enables the placement of $m$ to be deduced from any of the
corresponding $\mVar{oplace}$~\glspl{variable}.

We prevent control-flow \glspl{operation} from being moved to another
\gls{block} -- which in all likelihood would break \gls{program} semantics -- by
forcing selected \glspl{match} with control flow to be placed in the \gls{block}
matched by the \gls{UP graph}'s \gls{entry block}.
%
Hence, if \mbox{$\mEntry(m) \subseteq \mBlockSet$} returns either the empty set
or a set containing only the \gls{entry block} of \gls{match}~$m$ (when the
\gls{UP graph} has such a \gls{node}), then this \gls{constraint} is modeled as
%
\begin{equation}
  \forall m \in \mMatchSet,
  \forall o \in \mCovers(m),
  \forall b \in \mEntry(m) :
  \mVar{sel}[m] \mImp \mVar{oplace}[o] = b \hspace{-1pt}.
  \labelEquation{preventing-control-flow-op-moves}
\end{equation}

As stated previously, each \gls{datum}~$d$ must be \gls{define.d}[d] in some
\gls{block}~\mbox{$b \in \mBlockSet$} such that $b$ \gls{dominate.b}[s] every
\gls{block} wherein $d$ is \gls{use.d}[d], excluding \gls{use.d}[s] made by the
\glspl{phi-match}.
%
To this end, let \mbox{$\mDefines(m) \subseteq \mDataSet$} and \mbox{$\mUses(m)
  \subseteq \mDataSet$} denote the set of \glspl{datum} \gls{define.d}[d]
respectively \gls{use.d}[d] by \gls{match}~\mbox{$m$\hspace{-.8pt}.}
%
Let also \mbox{$\mDom(b) \subseteq \mBlockSet$} denote the set of \glspl{block}
\gls{dominate.b}[d] by \gls{block}~\mbox{$b$\hspace{-1pt}.}
%
With these definitions together with the fact that the placement of a
\gls{match} is deduced from its $\mVar{oplace}$~\glspl{variable}, the
\gls{constraint} can naively be modeled as
%
\begin{equation}
  \forall m \in \mPhiMatchCompSet,
  \forall d \in \mUses(m),
  \forall o \in \mCovers(m) :
  \mVar{dplace}[d] \in \mDom(\mVar{oplace}[o]),
  \labelEquation{naive-dom}
\end{equation}
%
where $\mPhiMatchCompSet \subseteq \mMatchSet$ denotes the \gls{match set}
without the \glspl{phi-match}.
%
This implementation has a number of flaws that will be explained and addressed
in \refChapter{solving-techniques}.
%
We therefore only use \refEquation{naive-dom} for sake of describing the
\glsshort{constraint model}, keeping in mind that a refined version is applied
in practice.

Next, we need to constrain the $\mVar{dplace}$~\glspl{variable} to depend on
where a selected \gls{match} is placed.
%
Intuitively, every \gls{datum} \gls{define.d}[d] by a \gls{match}~$m$ should be
placed in the same \gls{block} as $m$ together with all \glspl{operation}
covered by~\mbox{$m$\hspace{-.8pt}.}
%
This alone, however, could result in an over-constrained \glsshort{constraint
  model} that prevents selection of certain \glspl{match}.
%
For example, assume a \gls{match}~$m$ of the \gls{UP graph} shown in
\refFigure{up-graph-examples-add-graph} on
\refPageOfFigure{up-graph-examples-add-graph}, where the \glspl{block node}
\irBlock*{entry}, \irBlock*{clamp}, and \irBlock*{end} are matched to
\glspl{block} in $\mUFGraph$ labeled \irBlock*{A}, \irBlock*{B}, and
\irBlock*{C}, respectively.
%
Because of \refEquation{preventing-control-flow-op-moves}, $m$ must be placed in
the \irBlock*{A}~\gls{block}.
%
But because of \refEquation{def-edges}, one of its \glspl{value node} must be
placed in the \irBlock*{B}~\gls{block}.

Consequently, to allow such situations we relax the \gls{constraint} as follows.
%
First, we say that a \gls{match} \gls!{span.b}[s] the \glspl{block} matched by
the \gls{UP graph}'s \glspl{block node} (hence $m$ \gls{span.b}[s] \glspl{block}
\irBlock*{A}, \irBlock*{B}, and~\irBlock*{C}).
%
We also say that a \gls{match} \gls!{consume.b}[s] any matched \glspl{block}
where the corresponding \gls{block node} has both \gls{inbound.e} and
\gls{outbound.e} control-flow \glspl{edge} in the \gls{UP graph} (hence $m$
\gls{consume.b}[s] \gls{block}~\irBlock*{B}).
%
Using these definitions, we now enforce that every \gls{datum}~$d$
\gls{define.d}[d] by a \gls{match}~$m$ must be placed in the same \gls{block} as
$m$ only if $m$ \gls{span.b}[s] no \glspl{block}.
%
Otherwise $d$ may be \gls{define.d}[d] in any of the \glspl{block}
\gls{span.b}[ned] by~$m$ (one of which is equal to \mbox{$\mVar{oplace}[m]$}).
%
If \mbox{$\mSpans(m) \subseteq B$} denotes the set of \glspl{block}
\gls{span.b}[ned] by \gls{match}~\mbox{$m$\hspace{-.8pt},} then this constraint
is modeled as
%
\begin{equation}
  \begin{array}{c}
    \forall m \in \mMatchSet,
    \forall d \in \mDefines(m),
    \forall o \in \mCovers(m) : \\
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[d] \in \mSet{\mVar{oplace}[o]} \cup \mSpans(m).
  \end{array}
  \labelEquation{spanning}
\end{equation}

If a \gls{match} \gls{consume.b}[s] some \gls{block}, then it means that the
corresponding \gls{instruction} assumes full control of the control flow to and
from that \gls{block}.
%
Consequently, no \glspl{operation} covered by other \glspl{match} can be placed
in that \gls{block}.
%
Hence, if \mbox{$\mConsumes(m) \subseteq B$} denotes the set of \glspl{block}
\gls{consume.b}[d] by \gls{match}~\mbox{$m$\hspace{-.8pt},} then this constraint
is modeled as
%
\begin{equation}
  \begin{array}{c}
    \forall m \in \mMatchSet,
    \forall o \in \mOpSet \setminus \mCovers(m),
    \forall b \in \mConsumes(m) : \\
    \mVar{sel}[m]
    \mImp
    \mVar{oplace}[o] \neq b \hspace{-1pt}.
  \end{array}
  \labelEquation{consumption}
\end{equation}

Lastly, the restrictions imposed by the \glspl{definition edge} are modeled as
%
\begin{equation}
  \forall \mEdge{d}{b} \in \mFunctionDefEdgeSet :
  \mVar{dplace}[d] = b \hspace{-1.2pt},
  \labelEquation{def-edges}
\end{equation}
%
where $\mFunctionDefEdgeSet$ denotes the set of \glspl{definition edge} in
$\mUFGraph$.
%
It is assumed that the \glspl{edge} in $\mFunctionDefEdgeSet$ have been
reoriented such that all \glspl{source} are either \glsshort{state node} or
\glspl{value node} and all \glspl{target} are \glspl{block node}.


\section{Modeling Data Copying}
\labelSection{modeling-data-copying}

The cost of \gls{data copying} is taken into account by keeping track of the
storage requirements for the data used and produced by the selected
\glspl{match}.
%
The idea is as follows.
%
For each value~$v$ in the \gls{UF graph}, let a \gls{variable}~$\mVar{x}$ decide
in which \gls{location} on the \gls{target machine} $v$ is stored.
%
In this context a \gls!{location} is an abstract representation, typically
representing a \gls{register} but it could also indicate that the value is for
example stored in memory.
%
A \gls{match}~$m$ that either \gls{use.d}[s] or \gls{define.d}[s] $v$ and
requires $v$ to be in one of a set~$L$ of \glspl{location} can then enforce that
\mbox{$\mVar{x} \in L$}.


\paragraph{Variables}

The set of \glspl{variable} \mbox{$\mVar{loc}[d] \in \mLocationSet \cup
  \mSet{\mIntLocation}$} models in which \gls{location} \gls{datum}~$d$ is
available, where $\mLocationSet$ denotes the \gls!{location set} provided by the
\gls{target machine} and $\mIntLocation$ denotes a special \gls{location} for
values that cannot be reused across \glspl{instruction}.
%
The special \gls{location} is used for \glspl!{intermediate value}, which are
values produced within an \gls{instruction} and can only be accessed by this
very \gls{instruction}.
%
For example, the address computed by a memory load \gls{instruction} with a
sophisticated \gls{addressing mode} is produced within the pipeline and
therefore cannot be reused by other \glspl{instruction}.
%
A value which is not an \gls{intermediate value} is called an \gls!{exterior
  value}, meaning it can be accessed by other \glspl{instruction}.


\paragraph{Constraints}

Every \gls{datum} must be made available in a \gls{location} that is compatible
for all selected \glspl{match}.
%
Let \mbox{$\mStores(m\hspace{-.8pt}, d) \subseteq \mLocationSet \cup
  \mSet{\mIntLocation}$} denote the set of compatible \glspl{location}
(including the special \gls{location} for intermediate values) for a
\gls{datum}~$d$ \gls{define.d}[d] or \gls{use.d}[d] by a
\gls{match}~\mbox{$m$\hspace{-.8pt}.}
%
With this definition, the \gls{constraint} is modeled as
%
\begin{equation}
  \forall m \in \mMatchSet,
  \forall d \in \mDefines(m) \cup \mUses(m) : \\
  \mVar{sel}[m]
  \mImp
  \mVar{loc}[d] \in \mStores(m, d).
  \labelEquation{compatible-locations}
\end{equation}

As expected, \glspl{phi-match} require all of its \glspl{datum} to be stored in
the same \gls{location}.
%
This is modeled as
%
\begin{equation}
  \forall m \in \mPhiMatchSet \hspace{-.8pt},
  \forall d_1 \hspace{-.8pt}, d_2 \in \mDefines(m) \cup \mUses(m) :
  \mVar{sel}[m]
  \mImp
  \mVar{loc}[d_1] = \mVar{loc}[d_2].
  \labelEquation{phi-match-locations}
\end{equation}


\subsection{Copy Extension}

Depending on the \gls{target machine}, \refEquation{compatible-locations} can
result in an over-constrained \glsshort{constraint model}.
%
For example, in many \glspl{target machine} the \gls{SIMD.i} \glspl{instruction}
use a different set of \glspl{register} than the other, general
\glspl{instruction}.
%
In such situations, the \glspl{match} derived from the \gls{SIMD.i}
\glspl{instruction} and the \glspl{match} derived from the general
\glspl{instruction} will have non-overlapping \glspl{location} on the same
\glspl{datum} (that is, \mbox{$\mStores(m_1, d) \cap \mStores(m_2, d) =
  \mEmptySet$}).
%
Hence selection of such \glspl{match} is prevented.

Since non-overlapping \glspl{location} entail the need for copy
\glspl{instruction}, we extend the \gls{UF graph} with \glspl!{copy node}
through a process called \gls!{copy extension}.
%
For each \gls{data-flow edge}~\mbox{$\mEdge{v}{o}$\hspace{-.8pt},} where $v$ is
a \gls{value node} and $o$ is an \gls{operation}, we remove this \gls{edge} and
insert a new \gls{copy node}~$c$, a new \gls{value node}~$v'$\!, and new
\glspl{data-flow edge} such that
\mbox{$\mEdge{v}{\mEdge{c}{\mEdge{v'}{o}}}$\hspace{-.8pt}.}
%
If $o$ is a \gls{phi-node} then the corresponding \gls{definition edge}
connected to $v$ -- this is the \gls{edge} with the same \gls{outbound.e}
\gls{edge number} as the \gls{data-flow edge} -- is also moved to $v'$\!.
%
This is to ensure that the placement restrictions are applied only on the
\glspl{datum} actually used by the \glspl{phi-function} (that is, the copied
value and not the original value).

We also extend the \gls{pattern set} with a special \gls!{null-copy pattern},
with \gls{graph} structure \mbox{$\mEdge{v}{\mEdge{c}{v'}}$}\!, that covers $c$
at zero cost provided that \mbox{$\mVar{loc}[v] = \mVar{loc}[v']$}.
%
\Glspl{match} covering exactly one \gls{copy node} are called \glspl!{copy
  match}, and \glspl{match} derived from the \gls{null-copy pattern} are also
called \glspl!{null-copy match}.
%
Obviously, \glspl{null-copy pattern} emit nothing if selected.
%
If the \gls{null-copy match} cannot be selected for covering a particular
\gls{copy node}, then this means an appropriate copy \gls{instruction} must be
emitted whose cost will be accounted for.

In order to retain \gls{pattern matching}, we also need to perform \gls{copy
  extension} on every \gls{UP graph} in the \gls{pattern set}.
%
See for example \refFigure{copy-extending-pattern-example}.
%
\begin{figure}
  \setlength{\nodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original UP graph%
                  \labelFigure{copy-extending-pattern-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    copy-extending-pattern-example-before%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  After copy extension%
                  \labelFigure{copy-extending-pattern-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    copy-extending-pattern-example-after%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of copy-extending a pattern}
  \labelFigure{copy-extending-pattern-example}
\end{figure}
%
The \gls{UP graph} captures the behavior of an \gls{instruction} that adds two
values~\irVar*{r} and~\irVar*{s} and then shifts the result by one bit to the
right (\refFigure{copy-extending-pattern-example-before}).
%
Since we want to preserve the ability of selecting copy \glspl{instruction} for
moving \glspl{datum} between \glspl{instruction}, we only copy-extend the values
in a \gls{UP graph} which are both \gls{define.d}[d] and \gls{use.d}[d] by the
\gls{pattern}.
%
We also copy-extend any constant values since these obviously do not require a
separate copy \gls{instruction} to be used by the \gls{pattern}.
%
The resulting \gls{UP graph} will now yield the same \glspl{match} as before
\gls{copy extension} (\refFigure{copy-extending-pattern-example-after}).


\subsection{Handling Calling Conventions}

The \gls{data copying} method can also be used for handling \glspl{calling
  convention} of the specific \gls{target machine}.\!%
%
\footnote{%
  A \gls!{calling convention} is an implementation scheme that defines how
  arguments and return values are passed and received when making a
  \gls{function} call.
  %
  The \gls{function} from which the call is made is typically called the
  \gls!{caller}, and the \gls{function} to which the call is made is called the
  \gls!{callee}.
  %
  A \gls{calling convention} is specific for the \gls{target machine} and may
  therefore differ from one \glsshort{target machine} to another.
}
%
\Glspl{constraint} that \gls{callee} arguments must reside in a specific
\gls{location} are modeled as
%
\begin{equation}
  \forall d \in \mArgSet :
  \mVar{loc}[d] \in \mArgLoc(d).
  \labelEquation{function-args}
\end{equation}
%
where \mbox{$\mArgSet \subseteq \mDataSet$} denotes the set of \gls{function}
arguments in $\mUFGraph$ and \mbox{$\mArgLoc(d) \subseteq \mLocationSet$}
denotes the set of \glspl{location} in which argument~$d$ resides.
%
\Glspl{constraint} that certain arguments must reside on the stack can be
captured by introducing another special \gls{location} representing memory.
%
Hence, if an \gls{instruction} requires the argument to reside in a
\gls{register}, then the \gls{copy node} must be covered by a \gls{copy match}
that emits a memory load \gls{instruction}.

\Glspl{location} for caller arguments can be enforced either through
\refEquation{function-args} or through \refEquation{compatible-locations}.
%
If the \gls{calling convention} depends on the \gls{instruction} selected --
which is an unlikely scenario -- then the former is needed.
%
Otherwise the latter is more suitable as the restrictions can be enforced before
a \gls{match} is selected.\!%
%
\footnote{%
  If exactly one \gls{match}~$m$ can cover a given \gls{function} call
  \gls{node}, then both \glspl{constraint} provide the same amount of
  \gls{propagation} as \mbox{$\mVar{sel}[m] = 1$} will always hold for the
  implication in \refEquation{compatible-locations}.
}


\section{Modeling Value Reuse}
\labelSection{modeling-value-reuse}

Code quality can be increased if \glspl{instruction} are allowed to reuse copies
of values, which is a crucial feature to be expected in the code generated by
any modern \gls{instruction selector}.
%
See for example \refFigure{value-reuse-example}.
%
\begin{figure}
  \setlength{\nodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  A UF graph with two matches%
                  \labelFigure{value-reuse-example-uf-graph}%
                }%
                [50mm]%
                {\input{figures/constraint-model/value-reuse-example-uf-graph}}%
  \hfill%
  \subcaptionbox{%
                  UF graph after copy extension%
                  \labelFigure{value-reuse-example-after-ce}%
                }%
                [50mm]%
                {\input{figures/constraint-model/value-reuse-example-after-ce}}%
  \hfill%
  \mbox{}

  \vspace{\betweensubfigures}

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Redundant copying of values%
                  \labelFigure{value-reuse-example-redundant-copies}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/%
                    value-reuse-example-redundant-copies%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  Reuse of copied value%
                  \labelFigure{value-reuse-example-one-copy}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/value-reuse-example-one-copy%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of value reuse}
  \labelFigure{value-reuse-example}
\end{figure}
%
Originally, the \gls{UF graph} has a value~\irVar*{v} which is used by two
\glspl{operation} coverable by \glspl{match}~$m_1$ and~$m_2$
(\refFigure{value-reuse-example-uf-graph}).
%
After \gls{copy extension}, $m_1$ and $m_2$ use their own private copy of
\irVar*{v} -- \irVar*{v}[1] and \irVar*{v}[2], respectively
(\refFigure{value-reuse-example-after-ce}).
%
Assume that both $m_1$ and $m_2$ require its copy of \irVar*{v} to reside in a
\gls{location} different from \irVar*{v} -- for example, \irVar*{v} may reside
on the stack -- which means that selection of $m_1$ or $m_2$ also entails
emission of a copy \gls{instruction}.
%
With the \glsshort{constraint model} introduced thus far, two copy
\glspl{instruction} will be emitted if both $m_1$ and $m_2$ are selected
(\refFigure{value-reuse-example-redundant-copies}).
%
However, if \irVar*{v}[1] and \irVar*{v}[2] could reside in the same
\gls{location} then either of the values could be reused by either \gls{match},
thus requiring only one copy \gls{instruction}
(\refFigure{value-reuse-example-one-copy}).
%
We call this notion \gls!{value reuse}.

In this dissertation we consider two methods for reusing values:
%
\begin{inlinelist}[itemjoin={\ }, itemjoin*={\ and}]
  \item \gls{match duplication}
  \item \glspl{alternative value}
\end{inlinelist}.
%
We first introduce each in turn and then present experiments showing that one is
superior to the other.


\subsection{Match Duplication}

The idea behind \gls!{match duplication} is to duplicate appropriate
\glspl{match} in the \gls{match set} where \gls{value reuse} is possible.
%
We first say that two values~$v_1$ and~$v_2$ are \gls!{copy-related.d} if and
only if they are copies of the same value and $v_1$ and $v_2$ have the same data
type.
%
The second clause is necessary as copies of constants may be of different data
types and are therefore not interchangeable.
%
Then, for each \gls{match}~$m$ we create a new \gls{match} for each permutation
of \glspl{datum} that are \gls{copy-related.d} with the \glspl{input datum} in
\mbox{$m$\hspace{-.8pt},} where an \gls!{input datum} is a \gls{datum}
\gls{use.d}[d] but not \gls{define.d}[d] by~\mbox{$m$\hspace{-.8pt}.}
%
See for example \refFigure{match-duplication-example}.
%
\begin{figure}
  \setlength{\nodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original match set%
                  \labelFigure{match-duplication-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/match-duplication-example-before%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  After match duplication%
                  \labelFigure{match-duplication-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/match-duplication-example-after%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of match duplication}
  \labelFigure{match-duplication-example}
\end{figure}
%
The \gls{match set} contains a \gls{match}~$m$ that uses value~\irVar*{v}[1],
which is \gls{copy-related.d} with value~\irVar*{v}[2]
(\refFigure{match-duplication-example-before}).
%
Because \irVar*{v}[1] is an \gls{input datum} in~\mbox{$m$\hspace{-.8pt},} we
duplicate $m$ to instead use \irVar*{v}[2], resulting in \gls{match}~$m'$
(\refFigure{match-duplication-example-after}).

The main advantage of \gls{match duplication} is that no changes need to be done
for the \gls{constraint model}; the decision of which value to use (and reuse)
depends entirely on the selection of \glspl{match}.
%
However, this comes at a cost of inflating the \gls{match set}, which in turn
inflates the \gls{search space}.
%
If a \gls{match} has $k$~\glspl{input datum}, each with $n$~\gls{copy-related.d}
values, then $\mBigO(n^k)$ new \glspl{match} will be created.
%
Although the decision of \gls{value reuse} is intuitively orthogonal to the
decisions of selecting a \gls{match} and placing it into a \gls{block}, these
decisions must be remade for each new \gls{match}.
%
Consequently, the \gls{search space} is enlarged with many symmetric
\glspl{solution}.


\subsection{Alternative Values}

Instead of expanding the \gls{match set} (like in \gls{match duplication}), we
can postpone the decision of which \gls{input datum} to use for a particular
\gls{match} and integrate it as part of the \gls{constraint model}.
%
The idea is as follows.
%
For each \gls{match}~\mbox{$m$\hspace{-.8pt},} let every \glspl{input datum}~$d$
in $m$ be mapped to any \gls{datum} that is \gls{copy-related.d}
to~\mbox{$d$\hspace{-.8pt}.}
%
In other words, unlike before when a \gls{match} was \mbox{1-to-1} mapping
between \glspl{node} in the \gls{UP graph} and \glspl{node} in the \gls{UF
  graph}, we now allow certain mappings to be a \mbox{1-to-$n$} mapping.
%
See for example \refFigure{alt-values-example}.
%
\begin{figure}
  \setlength{\nodeDist}{12pt}%

  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original match set%
                  \labelFigure{alt-values-example-before}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/alt-values-example-without%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  With alternative values%
                  \labelFigure{alt-values-example-after}%
                }%
                [50mm]%
                {%
                  \input{%
                    figures/constraint-model/alt-values-example-with%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of alternative values}
  \labelFigure{alt-values-example}
\end{figure}
%
Again, the \gls{match set} contains a \gls{match}~$m$ that uses
value~\irVar*{v}[1], which is \gls{copy-related.d} with value~\irVar*{v}[2]
(\refFigure{alt-values-example-before}).
%
Because \irVar*{v}[1] is an \gls{input datum} in~\mbox{$m$\hspace{-.8pt},} we
extend the mapping from $n$ to \irVar*{v}[1] to include \irVar*{v}[2], where $n$
is the corresponding \gls{value node} in the \gls{UP graph} of~$m$
(\refFigure{alt-values-example-after}).
%
In this context, \irVar*{v}[1] and \irVar*{v}[2] are said to be
\glspl!{alternative value} to~\mbox{$m$\hspace{-.8pt}.}
%
For convenience, we assume that the set of \glspl{alternative value} for each
non-\gls{input datum}~$d$ in a \gls{match} contains only the \glsshort{state
  node} or \gls{value node} to which $d$ is already mapped.

Special care must be taken to \glspl{match} derived from the \gls{phi-pattern}.
%
Assume, for example, that the \gls{match}~$m$ using value~\irVar*{v}[1] in
\refFigure{alt-values-example-before} is a \gls{phi-match}.
%
This means that \irVar*{v}[1] will participate in a \gls{definition edge},
forcing \irVar*{v}[1] to be \gls{define.d}[d] in some \gls{block}.
%
If $m$ is extended as in \refFigure{alt-values-example-after}, then $m$ is
allowed to make use of value~\irVar*{v}[2], which does not participate in the
\gls{definition edge} and hence could break \gls{program} semantics.
%
There are two approaches to fixing this problem:
%
\begin{figure}
  \centering%
  \input{figures/constraint-model/ext-phi-pattern}

  \caption{Extended $\mPhi$-pattern}
  \labelFigure{ext-phi-pattern}
\end{figure}
%
\begin{inlinelist}[label=(\roman*), itemjoin={; }, itemjoin*={; or\ }]
  \item either all \glspl{phi-match} are excluded from being extended with
    \glspl{alternative value}
  \item the \gls{phi-pattern} is extended with \glspl{block node} and
    \glspl{definition edge} to allow the value placement restrictions to be
    captured as part of the \gls{match}
\end{inlinelist}.
%
The former is simpler but interferes with an \gls{implied.c} \gls{constraint} to
be introduced in
\refChapter{solving-techniques}~(\refEquation{dom-cons-kill-match-selection}),
which may remove potentially optimal \glspl{solution}.
%
Consequently we apply the latter, as shown in \refFigure{ext-phi-pattern}.
%
The extended \gls{phi-pattern} assumes that no value is used more than once by
the same \gls{phi-node}, and that no pair of values used by the same
\gls{phi-node} have \glspl{definition edge} to the same \gls{block}.
%
These invariants can be achieved by transforming the \gls{function} as needed
before \gls{pattern matching}.

After having extended the \gls{match set} with \glspl{alternative value}, the
next step is to extend the \gls{constraint model} with an another level of
indirection wherever a \gls{constraint} refers to a \gls{datum}.


\paragraph{Variables}

Assume first that each \glsshort{define.d}[ition] or \glsshort{use.d}[age] of
\glspl{datum} within each \gls{match} introduces a unique \gls!{operand}.
%
Instead of \glsshort{define.d}[ing] and \glsshort{use.d}[ing] \glspl{datum}, we
now assume that all \glspl{match} \gls{define.d} and \gls{use.d}
\glspl{operand}.
%
The set of \glspl{variable} \mbox{$\mVar{alt}[p] \in \mDataSet[p]$} models to
which \gls{datum} \gls{operand}~\mbox{$p \in \mOperandSet$} is mapped, where
\mbox{$\mDataSet[p] \subseteq \mDataSet$} denotes the set of \glspl{alternative
  value} for~$p$ and $\mOperandSet$ denotes the set of \glspl{operand}
introduced by~$\mMatchSet$.


\paragraph{Constraints}

As stated previously, the aim is to add another level of indirection whenever a
\gls{constraint} refers to a \gls{datum}.
%
To this end, let \mbox{$\mDefines(m) \subseteq \mOperandSet$} and
\mbox{$\mUses(m) \subseteq \mOperandSet$} now denote the set of \glspl{operand}
(instead of \glspl{datum}) \gls{define.d}[d] respectively \gls{use.d}[d] by
\gls{match}~\mbox{$m$\hspace{-.8pt}.}
%
With these definitions, \refEquationList{naive-dom, spanning,
  compatible-locations, phi-match-locations} are adjusted accordingly (the
changes are highlighted in gray):
%
\begin{equation}
  \forall m \in \mPhiMatchCompSet,
  \forall \hlDiff{p} \in \mUses(m),
  \forall o \in \mCovers(m) :
  \mVar{dplace}[\hlDiff{\mVar{alt}[p]}[1pt]] \in \mDom(\mVar{oplace}[o]),
  \labelEquation{naive-dom-alt}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \forall m \in \mMatchSet,
    \forall \hlDiff{p} \in \mDefines(m),
    \forall o \in \mCovers(m) : \\
    \mVar{sel}[m]
    \mImp
    \mVar{dplace}[\hlDiff{\mVar{alt}[p]}[1pt]] \in
      \mSet{\mVar{oplace}[o]} \cup \mSpans(m),
  \end{array}
  \labelEquation{spanning-alt}
\end{equation}
%
\begin{equation}
  \forall m \in \mMatchSet,
  \forall \hlDiff{p} \in \mDefines(m) \cup \mUses(m) :
  \mVar{sel}[m]
  \mImp
  \mVar{loc}[\hlDiff{\mVar{alt}[p]}[1pt]] \in \mStores(m, \hlDiff{p}),
  \labelEquation{compatible-locations-alt}
\end{equation}
%
\begin{equation}
  \begin{array}{c}
    \forall m \in \mPhiMatchSet,
    \forall \hlDiff{p}_1 \hspace{-.8pt}, \hlDiff{p}_2 \in
      \mDefines(m) \cup \mUses(m) : \\
    \mVar{sel}[m]
    \mImp
    \mVar{loc}[\hlDiff{\mVar{alt}[p_1]}] = \mVar{loc}[\hlDiff{\mVar{alt}[p_2]}].
  \end{array}
  \labelEquation{phi-match-locations-alt}
\end{equation}

Due to these changes, there may be \glspl{datum} that is not \gls{use.d}[d] by
any \gls{match}.
%
However, \refEquation{data-definitions} still requires that every \gls{datum}
must be \gls{define.d}[d] by some \gls{match}.
%
We address this by extending the \gls{pattern set} with a \gls!{kill pattern}
with \gls{graph} structure \mbox{$\mEdge{v}{\mEdge{c}{v'}}$}\!, where $v$ and
$v'$ are \glspl{value node} and $c$ is a \gls{copy node}.
%
\Glspl{match} derived from this \gls{pattern} are called \glspl!{kill match},
which have zero cost and emit nothing if selected.
%
A \gls{datum} is said to be \gls!{killed.d} if and only if it is
\gls{define.d}[d] by a \gls{kill match}, and non-\glspl{kill match} are only
allowed to make \gls{use.d} of non-\gls{killed.d} \glspl{datum}.

To model whether a \gls{datum} is \gls{killed.d}, we extend the \gls{location
  set} with a special \gls{location}~$\mKilledLocation$ and require that a
\gls{kill match}~$m$ is selected if and only if the \gls{location} of the
\gls{datum} \gls{define.d}[d] by $m$ is $\mKilledLocation$.
%
This is modeled as
%
\begin{equation}
  \forall m \in \mKillMatchSet,
  \forall p \in \mDefines(m) :
  \mVar{sel}[m] \mEq \mVar{loc}[\mVar{alt}[p]] = \mKilledLocation,
  \labelEquation{killed-data}
\end{equation}
%
where \mbox{$\mKillMatchSet \subseteq \mMatchSet$} denotes the set of
\glspl{kill match}.

Lastly, we need to enforce the value placements appearing in the
\glspl{phi-match}.
%
Let $\mMatchDefEdgeSet$ denote this set of value placements, encoded as a
tuple~\mbox{$\mTuple{m\hspace{-.8pt}, b\hspace{-1pt}, p}$} for each
\gls{definition edge} between a \gls{block}~$b$ and an operand~$p$ appearing in
\gls{match}~\mbox{$m$\hspace{-.8pt}.}
%
These \glspl{constraint} are then modeled as
%
\begin{equation}
  \forall \mTuple{m, b, p} \in \mMatchDefEdgeSet :
  \mVar{sel}[m] \mImp \mVar{dplace}[\mVar{alt}[p]] = b \hspace{-1pt}.
  \labelEquation{match-def-edges}
\end{equation}


\subsection{Experimental Evaluation}

We first evaluate the two different methods for \gls{value reuse}.
%
Based on the results, we then evaluate the impact of \gls{value reuse} using the
superior method.

When filtering, we remove all \glspl{function} that have fewer than
ten~\gls{LLVM} \gls{IR} \glspl{instruction} and more than
\num{50}~\glspl{instruction}.
%
Anything smaller will most likely not be benefited by \gls{value reuse}, and
anything larger will lead to unreasonably long solving times.
%
This leaves a pool of \num{453}~\glspl{function}, from which we then draw
\num{20}~samples.


\paragraph{Match Duplication \versus Alternative Values}

We evaluate the different methods of \gls{value reuse} by comparing the solving
time exhibited by two \glsplshort{constraint model}:
%
\begin{modelList}
  \item \labelModel{match-dup}
    one based on \gls{match duplication}
  \item \labelModel{alt-values}
    one based on \glspl{alternative value}
\end{modelList}.
%
Since \gls{match duplication} yields an exponential increase in number of
\glspl{match} compared to \glspl{alternative value}, we expect
\glsshort{constraint model}~\refModel{alt-values} to perform better than
\glsshort{constraint model}~\refModel{match-dup}.

\RefFigure{alt-values-vs-match-dup-solving-time-plot} shows the normalized
solving times (including \gls{presolving} time) for the two \glspl{constraint
  model} described above, with \glsshort{constraint model}~\refModel{match-dup}
as \gls{baseline} and \glsshort{constraint model}~\refModel{alt-values} as
\gls{subject}.
%
\begin{figure}
  \centering%
  \maxsizebox{\textwidth}{!}{%
    \trimBarchartPlot{%
      \input{\expDir/alt-values-vs-match-dup-pre+solving-time-speedup.plot}%
    }%
  }

  \caption[%
            Plot for evaluating match duplication's and alternative values'
            impact on solving time%
          ]%
          {%
            Normalized solving times (incl.\ presolving time) for two
            constraint models supporting value reuse:
            %
            \begin{inlinelist}[itemjoin={, }, itemjoin*={, and}]
              \item one based on match duplication (baseline)
              \item one based on alternative values (subject)
            \end{inlinelist}.
            %
            GMI:~\printGMI{%
              \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupGmean%
            },
            CI~\printGMICI{%
              \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMin%
            }{%
              \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMax%
            }%
          }
  \labelFigure{alt-values-vs-match-dup-solving-time-plot}
\end{figure}
%
All \glspl{function} are solved to optimality.
%
The solving times range from
\printMinSolvingTime[round-precision=1]{
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupSolvingTimeAvgMin,
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupBaselineSolvingTimeAvgMin
}
to
\printMaxSolvingTime{
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupSolvingTimeAvgMax,
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupBaselineSolvingTimeAvgMax
}
with a \gls{CV} of
\numMaxOf{
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeCvMax,
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupBaselinePrePlusSolvingTimeCvMax
}.
%
The \gls{GMI} is \printGMI{%
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupGmean%
} with \gls{CI}~\printGMICI{%
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMin%
}{%
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMax%
}.

We see clearly that \glsshort{constraint model}~\refModel{alt-values} results in
considerably shorter solving times than \glsshort{constraint
  model}~\refModel{match-dup}.
%
For one \gls{function} (\cCode*{reg2rsaref}), the solving time is improved
by~\printZCNorm{%
  \AltValuesVsMatchDupPrePlusSolvingTimeSpeedupPrePlusSolvingTimeZeroCenteredSpeedupMax%
}.
%
This is due to a high rate of \gls{copy-related.d} values for which
\glspl{alternative value} results in only \num{94}~\glspl{match} whereas
\gls{match duplication} results in \num{537}~\glspl{match}.
%
Hence \glspl{alternative value} is a better design choice over \gls{match
  duplication} when implementing \gls{value reuse}.


\paragraph{Impact of Value Reuse}

We evaluate the impact of \gls{value reuse} by comparing the cost (that is, the
total number of cycles as described in \refSection{cm-objective-function}) of
the optimal \glspl{solution} produced by two \glsplshort{constraint model}:
%
\begin{modelList}
  \item \labelModel{wo-value-reuse}
    one without \gls{value reuse} support
  \item \labelModel{w-value-reuse}
    one with this support (based on \glspl{alternative value})
\end{modelList}.
%
Since \gls{value reuse} reduces the number of selected copy \glspl{instruction},
we expect \glsshort{constraint model}~\refModel{w-value-reuse} to produce
\glspl{solution} with less cost compared with \glsshort{constraint
  model}~\refModel{wo-value-reuse}.

\RefFigure{alt-values-vs-without-cycles-plot} shows the normalized
\gls{solution} costs for the two \glspl{constraint model} describe above, with
\glsshort{constraint model}~\refModel{wo-value-reuse} as \gls{baseline} and
\glsshort{constraint model}~\refModel{w-value-reuse} as \gls{subject}.
%
\begin{figure}
  \centering%
  \maxsizebox{\textwidth}{!}{%
    \trimBarchartPlot{%
      \input{\expDir/alt-values-vs-without-cycles-speedup.plot}%
    }%
  }

  \caption[Plot for evaluating value reuse's impact on code quality]%
          {%
            Normalized optimal solution costs for two constraint models:
            \begin{inlinelist}[itemjoin={, }, itemjoin*={, and}]
              \item one without value reuse support (baseline)
              \item one with such support (subject)
            \end{inlinelist}.
            %
            GMI:~\printGMI{%
              \AltValuesVsWithoutCyclesSpeedupCyclesRegularSpeedupGmean%
            },
            CI:~\printGMICI[round-precision=3]{%
              \AltValuesVsWithoutCyclesSpeedupCyclesRegularSpeedupCiMin%
            }{%
              \AltValuesVsWithoutCyclesSpeedupCyclesRegularSpeedupCiMax%
            }%
          }
  \labelFigure{alt-values-vs-without-cycles-plot}
\end{figure}
%
All \glspl{function} are solved to optimality.
%
The costs range from
\printMinCycles{%
  \AltValuesVsWithoutCyclesSpeedupCyclesAvgMin,
  \AltValuesVsWithoutCyclesSpeedupBaselineCyclesAvgMin
} to
\printMaxCycles{%
  \AltValuesVsWithoutCyclesSpeedupCyclesAvgMax,
  \AltValuesVsWithoutCyclesSpeedupBaselineCyclesAvgMax
}.
%
The \gls{GMI} is \printGMI{%
  \AltValuesVsWithoutCyclesSpeedupCyclesRegularSpeedupGmean%
} with \gls{CI}~\printGMICI[round-precision=3]{%
  \AltValuesVsWithoutCyclesSpeedupCyclesRegularSpeedupCiMin%
}{%
  \AltValuesVsWithoutCyclesSpeedupCyclesRegularSpeedupCiMax%
}.

We see clearly that \glsshort{constraint model}~\refModel{w-value-reuse}
produces \glspl{solution} with significantly less cost than those produced by
\glsshort{constraint model}~\refModel{wo-value-reuse}.
%
For one \gls{function} (\cCode*{putseqdispext}), the cycle count is reduced from
\num{256}~cycles to \num{208}~cycles (an improvement
of~\printZCNorm{%
  \AltValuesVsWithoutCyclesSpeedupCyclesZeroCenteredSpeedupMax%
}).
%
This is because two constants are frequently used as arguments to \gls{function}
call \glspl{instruction} and thus cannot be loaded as immediates.
%
Hence \gls{value reuse} is essential for reducing the number of copy
\glspl{instruction} and, subsequently, lowering cost.


\paragraph{Conclusions}

From the results for these experiments, we conclude:
%
\begin{enumerate*}[label=(\roman*), itemjoin={;\ }, itemjoin*={; and\ }]
  \item that \glspl{alternative value} are superior to \gls{match duplication}
  \item that \gls{value reuse} significantly improves code quality
\end{enumerate*}.


\section{Modeling Block Ordering}
\labelSection{modeling-block-ordering}

Ordering the \glspl{block} in a \gls{function} entails finding a sequence~$s$
such that each \gls{block} appears exactly once in~\mbox{$s$\hspace{-.8pt}.}
%
Depending on the control-flow \glspl{instruction} selected, some \glspl{block}
may need to be adjacent.
%
For example, assume a \gls{block}~$b$ that branches to either of two
\glspl{block}~$c$ and~$d$ depending on whether a condition holds.
%
Assume also that the conditional branching in $b$ is implemented using an
\gls{instruction} that branches to $c$ if the condition holds, otherwise it
continues the execution with the next \gls{instruction} in the \gls{assembly
  code}.
%
This method of branching is called \gls!{fall-through}, and due to this $d$
must be placed immediately after $b$ in~\mbox{$s$\hspace{-.8pt}.}

For some combinations of \glspl{function} and \glspl{target machine} with
\gls{fall-through} \glspl{instruction}, there exists no valid \gls{block}
sequence without inserting one or more additional jump \glspl{instruction}.
%
See for example \refFigure{jump-insert-example}.
%
\begin{figure}
  \setlength{\nodeDist}{20pt}%
  \tikzset{
    block node/.append style={
      minimum width=2cm,
      minimum height=.9\nodeSize,
    },
  }%

  \mbox{}%
  \hfill%
  \subcaptionbox{Control-flow graph\labelFigure{jump-insert-example-cfg}}%
                [34mm]%
                {%
                  \input{figures/constraint-model/jump-insert-example-cfg}%
                }%
  \hfill%
  \subcaptionbox{%
                  Valid block sequences, after jump insertion%
                  \labelFigure{jump-insert-example-solutions}%
                }%
                [65mm]%
                {%
                  \input{figures/constraint-model/jump-insert-example-sol1}%
                  \hspace{6mm}%
                  \input{figures/constraint-model/jump-insert-example-sol2}%
                }%
  \hfill%
  \mbox{}

  \caption[Example that requires additional jump instructions]%
          {%
            Example that requires additional jump instructions.
            %
            It is assumed that the conditional \instrCode*{br}~instruction
            falls through to the next instruction if the condition is false%
          }
  \labelFigure{jump-insert-example}
\end{figure}
%
\Glspl{block}~\irBlock*{A} and~\irBlock*{B} both contain control-flow
\glspl{instruction} that branch to the beginning of \irBlock*{B} if the
condition holds, otherwise they branch to \gls{block}~\irBlock*{C}
(\refFigure{jump-insert-example-cfg}).
%
Because of the fall-through \gls{constraint}, \irBlock*{A} and \irBlock*{B}
cannot both have \irBlock*{C} as its successor \gls{block}.
%
Hence an additional jump \gls{instruction} that directly branches to
\irBlock*{C} must be inserted after the control-flow \gls{instruction} in either
\irBlock*{A} or~\irBlock*{B} (\refFigure{jump-insert-example-solutions}).

In this dissertation we consider two methods for inserting jump
\glspl{instruction} when required:
%
\begin{inlinelist}[itemjoin={\ }, itemjoin*={\ and}]
  \item \gls{branch extension}
  \item \glspllong{DTB pattern}
\end{inlinelist}.
%
We first introduce the \glspl{variable} and \glspl{constraint} for modeling
\gls{block ordering} before introducing each method in turn, and then present
experiments showing that one is superior to the other.


\paragraph{Variables}

The set of \glspl{variable} \mbox{$\mVar{succ}[b] \in \mBlockSet$} models the
successor of \gls{block}~\mbox{$b$\hspace{-1pt}.}
%
For example, if \mbox{$\mVar{succ}[b] = b'$}, then \gls{block}~$b'$ appears
immediately after \gls{block}~$b$ in the \gls{block ordering} sequence.


\paragraph{Constraints}

A \gls{solution} to the \gls{block ordering} problem is a sequence of
\gls{block} successors such that they form a \gls{Hamiltonian.c} \gls{cycle}.
%
Using the \gls{circuit constraint} defined in
\refChapter{constraint-programming} on \refPageOfDefinition{circuit}, this
\gls{constraint} is modeled as
%
\begin{equation}
  \mCircuit(\mVar{succ}[b_1], \ldots, \mVar{succ}[b_n]),
  \labelEquation{block-order}
\end{equation}
%
where \mbox{$b_1, \ldots, b_n = \mBlockSet$}.

If a \gls{match}~$m$ with an \gls{entry block} is derived from an
\gls{instruction} that performs a \gls{fall-through} to
\gls{block}~\mbox{$b$\hspace{-1pt},} then the \gls{constraint} can naively be
modeled as \mbox{$\mVar{sel}[m] \mImp \mVar{succ}[\mEntry(m)] =
  b$\hspace{-1pt}.}
%
However, this \gls{constraint} is too limiting as it disallows \gls{empty.b}
\glspl{block} to be placed between $\mEntry(m)$ and~\mbox{$b$\hspace{-1pt},}
thus forcing redundant jump \glspl{instruction} to be emitted.
%
A \gls{block}~$b$ is considered \gls!{empty.b} if either no \glspl{match} are
placed in $b$ or every \gls{match} in $b$ is a \gls!{null match}, which is a
\gls{match} that emits nothing if selected.
%
As \gls{empty.b} \glspl{block} are not uncommon to appear in the \gls{function}
under compilation -- especially when having performed \gls{global code motion}
-- this may have a significant impact on code quality.

Hence we extend the naive implementation above into a disjunction, where the
second clause models \glspl{fall-through} via single \gls{empty.b}
\glspl{block}.
%
Let $\mFallThroughSet$ denote a set of
pairs~\mbox{$\mPair{m\hspace{-.8pt}}{b}$,} where $m$ is a \gls{match} and $b$ is
a \gls{block} through which $m$ will fall if selected, and let $\mNullMatchSet$
denote the set of \glspl{null match}.
%
With these definitions, the \gls{fall-through} \gls{constraint} is modeled as
%
\begin{equation}
  \begin{array}{c}
    \forall \mPair{m}{b} \in \mFallThroughSet :
    \mVar{sel}[m]
    \mImp
    \mVar{succ}[\mEntry(m)] = b \mOr \mbox{} \\
    \big(
      \mVar{succ}[\mVar{succ}[\mEntry(m)]] = b
      \mAnd
      \mEmptyBlock(\mVar{succ}[\mEntry(m)])
    \big),
  \end{array}
  \labelEquation{fall-through}
\end{equation}
%
where
%
\begin{equation}
  \mEmptyBlock(b)
  \equiv
  \mBigAnd_{\mathclap{o \,\in\, \mOpSet}}
  (
  \mVar{oplace}[o] \neq b
  \mOr
  \mVar{omatch}[o] \in \mNullMatchSet
  ).
\end{equation}

If a \gls{block}~$b$ unconditionally branches to another \gls{block}~$b'$ and
$b'$ appears immediately after $b$ in the \gls{block} sequence, then a jump
\gls{instruction} is redundant.
%
To prevent emission of such jump \glspl{instruction}, we extend the \gls{pattern
  set} with a special \gls!{null-jump pattern}, with \gls{graph} structure
\mbox{$\mEdge{b}{\mEdge{c}{b'}}$}\!, that covers a \gls{control node}~$c$ at
zero cost provided that \mbox{$\mVar{succ}[b] = b'$}\!.

\Glspl{fall-through} to or via the \gls{function}'s \gls{entry block} is never
allowed since that \gls{block} must always be placed first in the \gls{block}
sequence.
%
If $\mFunctionEntryBlock$ denotes the \gls{function}'s \gls{entry block}, then
this \gls{constraint} is modeled as
%
\begin{equation}
  \forall \mPair{m}{\cdot} \in \mFallThroughSet :
  \mVar{sel}[m]
  \mImp
  \mVar{succ}[\mEntry(m)] \neq \mFunctionEntryBlock.
  \labelEquation{no-fall-through-to-fun-entry}
\end{equation}


\subsection{Branch Extension}

One method of inserting jump \glspl{instruction} is to extend the \gls{UF graph}
with additional \glsshort{block node} and \glspl{control node}.
%
The idea, called \gls!{branch extension}, is as follows.
%
For each \gls{control-flow edge}~$\mPair{c}{b}$, where $c$ is a \gls{control
  node} representing a conditional branch and $b$ is a \gls{block node}, we
remove this \gls{edge} and insert a new \gls{block node}~$b'$\!, a
new\gls{control node}~\mbox{$c'$\hspace{-1pt},} and new \glspl{control-flow
  edge} such that \mbox{$\mEdge{c}{\mEdge{b'}{\mEdge{c'}{b}}}$\hspace{-1pt}.}
%
An example is shown in \refFigure{branch-extension-example}.
%
If the new \gls{control node} is indeed redundant, then it can be covered by a
\gls{match} derived from the \gls{null-jump pattern}.
%
This in turn causes the new \glspl{block} to become \gls{empty.b} and appear
immediately before the target \gls{block}.
%
Like with \gls{copy extension}, to retain \gls{pattern matching} we also perform
\gls{branch extension} on each \gls{UF graph} in the \gls{pattern set}.

\begin{figure}
  \mbox{}%
  \hfill%
  \subcaptionbox{%
                  Original UF subgraph%
                  \labelFigure{branch-extension-example-original}%
                }%
                [35mm]%
                {%
                  \input{%
                    figures/constraint-model/branch-extension-example-before%
                  }%
                }%
  \hfill%
  \subcaptionbox{%
                  After branch extension%
                  \labelFigure{branch-extension-example-after}%
                }%
                [40mm]%
                {%
                  \input{%
                    figures/constraint-model/branch-extension-example-after%
                  }%
                }%
  \hfill%
  \mbox{}

  \caption{Example of branch extension}%
  \labelFigure{branch-extension-example}
\end{figure}

The disadvantage of \gls{branch extension} is that it inflates the \gls{search
  space}.
%
The number of \glsshort{block node} and \glspl{control node} both increase by
$\mBigO(nk)$, where $n$ is the number of \glspl{block} before \gls{branch
  extension} and $k$ is the highest number of \gls{outbound.e}
\glspl{control-flow edge} from a \gls{control node} in the \gls{UF graph}.
%
This leads to more \glspl{operation} to be covered and more \glspl{block}
wherein an \gls{operation} may be placed.
%
In addition, as the majority of the new \glspl{block} will be \gls{empty.b},
situations often arise where a control-flow \gls{instruction} could successfully
fall through more than one \gls{block}.
%
Because of \refEquation{fall-through}, however, it can only fall through at most
one \gls{empty.b} \gls{block}, causing emission of redundant jump
\glspl{instruction} that would not have been emitted had \gls{branch extension}
not been performed.


\subsection{Dual-target Branch Patterns}

\def\jmpPattern{p_{\mathsc{jmp}}}%

\glsreset{DTB pattern}

Another method is to extend the \gls{pattern set} with so-called \glspl!{DTB
  pattern}.
%
Given a \gls{pattern set}~$S$, first find a \gls{pattern}~\mbox{$\jmpPattern \in
  S$} corresponding to an unconditional jump \gls{instruction} that directly
branches to a given label (it is reasonable to assume such a \gls{pattern}
always exist for any given \gls{target machine}).
%
Let \mbox{$\mCost(p)$} and \mbox{$\mEmits(p)$} denote the cost of pattern~$p$
respectively the sequence of \glspl{instruction} emitted by $p$ if selected.
%
Then, for each \gls{pattern}~\mbox{$p \in S$} corresponding to a conditional
jump \gls{instruction} that falls through to a given
\gls{block}~\mbox{$b$\hspace{-1pt},} we add a new \gls{pattern} to~$S$.
%
This new \gls{pattern} is a copy of $p$ but has no \gls{fall-through}
\gls{constraint}, it emits $\mEmits(p)$ followed by $\mEmits(\jmpPattern)$, and
it has cost \mbox{$\mCost(p) + \mCost(\jmpPattern)$}.
%
An example is shown in \refFigure{dual-target-branch-pattern-example}.
%
\begin{figure}
  \subcaptionbox{%
                  A pattern that falls through to the \irBlock*{false} block%
                  \labelFigure{dual-target-branch-pattern-example-original}%
                }%
                [68mm]%
                {%
                  \begin{tabular}{c}
                    \input{%
                      figures/constraint-model/%
                      dual-target-branch-pattern-example%
                    }\\[.5\betweensubfigures]
                    \figureFont\figureFontSize%
                    \begin{tabular}{lc}
                      \toprule
                        \multicolumn{1}{c}{\tabhead emit} & \tabhead cost\\
                      \midrule
                        {\instrFont br b, true} & $2$\\
                      \bottomrule
                    \end{tabular}%
                  \end{tabular}%
                }%
  \hfill%
  \subcaptionbox{%
                  New pattern, without fall-through%
                  \labelFigure{dual-target-branch-pattern-example-copy}%
                }%
                [52mm]%
                {%
                  \begin{tabular}{c}
                    \newcommand{\fallthruString}{}%
                    \input{%
                      figures/constraint-model/%
                      dual-target-branch-pattern-example%
                    }\\[.5\betweensubfigures]
                    \figureFont\figureFontSize%
                    \begin{tabular}{lc}
                      \toprule
                        \multicolumn{1}{c}{\tabhead emit} & \tabhead cost\\
                      \midrule
                        {\instrFont br b, true}
                      & $2 + \mCost\hspace{.4pt}(\jmpPattern)$\\
                        $\mEmits(\jmpPattern)$
                      & \\
                      \bottomrule
                    \end{tabular}%
                  \end{tabular}%
                }

  \caption{Example of creating a DTB pattern}%
  \labelFigure{dual-target-branch-pattern-example}
\end{figure}
%
Because a \gls{DTB pattern} has no \gls{fall-through} \gls{constraint}, it
essentially models a conditional jump \gls{instruction} capable of directly
branching to two \glspl{block} (hence the name).

Consequently, if a \gls{pattern set} contains $k$~\glspl{pattern} with
\gls{fall-through} \glspl{constraint} and a \gls{UF graph} contains
$n$~\glspl{control node} representing conditional jumps, then using \glspl{DTB
  pattern} will enlarge the \gls{match set} by $\mBigO(nk)$~\glspl{match}.
%
Unlike \gls{branch extension}, however, the \gls{UF graph} does not need to be
extended with additional \glspl{block} wherein \glspl{operation} may be placed,
which results in a significantly smaller \gls{search space}.


\subsection{Experimental Evaluation}

We evaluate the different methods for inserting jump \glspl{instruction} by
comparing the solving times exhibited and the cost of the optimal
\glspl{solution} produced by two versions of the \gls{constraint model}:
%
\begin{modelList}
  \item \labelModel{branch-ext}
    one based on \gls{branch extension}
  \item \labelModel{dual-target}
    one based on \glspl{DTB pattern}
\end{modelList}.
%
Since \gls{branch extension} yields a larger number of \glspl{block} compared to
\glspl{DTB pattern}, we expect \glsshort{constraint
  model}~\refModel{dual-target} to outperform \glsshort{constraint
  model}~\refModel{branch-ext}.
%
Moreover, many of the \glspl{block} introduced by \gls{branch extension} will
most likely be \gls{empty.b} and thereby cause emission of redundant jump
\glspl{instruction}.
%
Consequently, we also expect \glsshort{constraint model}~\refModel{dual-target}
to yield better code quality than \glsshort{constraint
  model}~\refModel{branch-ext}.

When filtering, we remove all \glspl{function} that have fewer than
\num{20}~\gls{LLVM} \gls{IR} \glspl{instruction} and more than
\num{100}~\glspl{instruction}.
%
Anything smaller will most likely not require any additional jump
\glspl{instruction}, and anything larger will lead to unreasonably long
experiment runtimes.
%
This leaves a pool of \num{413}~\glspl{function}, from which we then draw
\num{20}~samples.

When clustering, we replace the number of memory \glspl{instruction} as feature
with the number of \glspl{block}.
%
This is to evaluate how the methods behave as the number of \glspl{block} grow
larger.


\paragraph{Impact on Solving Time}

\RefFigure{dual-target-branch-patterns-vs-branch-extension-solving-time-plot}
shows the normalized solving times (including \gls{presolving} time) for the two
\glspl{constraint model} described above, with \glsshort{constraint
  model}~\refModel{branch-ext} as \gls{baseline} and \glsshort{constraint
  model}~\refModel{dual-target} as \gls{subject}.
%
\begin{figure}
  \centering%
  \maxsizebox{\textwidth}{!}{%
    \trimBarchartPlot{%
      \input{%
        \expDir/%
        dual-target-patterns-vs-branch-ext-pre+solving-time-speedup.plot%
      }%
    }%
  }

  \caption[%
            Plot comparing solving times for two constraint models supporting
            jump instruction insertion%
          ]%
          {%
            Normalized solving times (incl.\ presolving time) for two
            constraint models supporting jump insertion:
            %
            \begin{inlinelist}[itemjoin={, }, itemjoin*={, and}]
              \item one based on branch extension (baseline)
              \item one based on DTB patterns (subject)
            \end{inlinelist}.
            %
            GMI:~\printGMI{%
              \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupGmean%
            },
            CI~\printGMICI{%
              \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMin%
            }{%
              \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMax%
            }%
          }
  \labelFigure{%
    dual-target-branch-patterns-vs-branch-extension-solving-time-plot%
  }
\end{figure}
%
All \glspl{function} are solved to optimality and arranged in increasing order
of number of conditional jump \glspl{instruction}.
%
The solving times range from
\printMinSolvingTime[round-precision=2]{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupSolvingTimeAvgMin,
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupBaselineSolvingTimeAvgMin
}
to
\printMaxSolvingTime{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupSolvingTimeAvgMax,
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupBaselineSolvingTimeAvgMax
}
with a \gls{CV} of
\numMaxOf{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupSolvingTimeCvMax,
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupBaselineSolvingTimeCvMax
}.
The \gls{GMI} is \printGMI{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupGmean%
} with \gls{CI}~\printGMICI{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMin%
}{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupPrePlusSolvingTimeRegularSpeedupCiMax%
}.

We see clearly that \glsshort{constraint model}~\refModel{dual-target} results
in considerably shorter solving times than \glsshort{constraint
  model}~\refModel{branch-ext}.
%
For one \gls{function} (\cCode*{gluEndPolygon}), the solving time is improved
by~\printZCNorm{%
  \DualTargetPatternsVsBranchExtPrePlusSolvingTimeSpeedupPrePlusSolvingTimeZeroCenteredSpeedupMax%
}.
%
We also observe that, as expected, when the number of conditional jump
\glspl{instruction} increases -- up to \num{13}, in the case of
\cCode*{nextkeypacket} -- the \gls{search space} for \glsshort{constraint
  model}~\refModel{branch-ext} grows faster than for \glsshort{constraint
  model}~\refModel{dual-target}.
%
Hence, in terms of solving time \glspl{DTB pattern} is a better design choice
over \gls{branch extension} when implementing insertion of jump
\glspl{instruction}.


\paragraph{Impact on Code Quality}

\RefFigure{dual-target-branch-patterns-vs-branch-extension-cycles-plot} shows
the normalized \gls{solution} costs for the two \glspl{constraint model}
described above, with \glsshort{constraint model}~\refModel{branch-ext} as
\gls{baseline} and \glsshort{constraint model}~\refModel{dual-target} as
\gls{subject}.
%
\begin{figure}
  \centering%
  \maxsizebox{\textwidth}{!}{%
    \trimBarchartPlot{%
      \input{\expDir/dual-target-patterns-vs-branch-ext-cycles-speedup.plot}%
    }%
  }

  \caption[%
            Plot comparing optimal solution costs for two constraint models
            supporting jump instruction insertion%
          ]%
          {%
            Normalized optimal solution costs for two constraint models
            supporting jump insertion:
            %
            \begin{inlinelist}[itemjoin={, }, itemjoin*={, and}]
              \item one based on branch extension (baseline)
              \item one based on DTB patterns (subject)
            \end{inlinelist}.
            %
            GMI:~\printGMI{%
              \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesRegularSpeedupGmean%
            },
            CI~\printGMICI[round-precision=3]{%
              \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesRegularSpeedupCiMin%
            }{%
              \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesRegularSpeedupCiMax%
            }%
          }
  \labelFigure{dual-target-branch-patterns-vs-branch-extension-cycles-plot}
\end{figure}
%
All \glspl{function} are solved to optimality and arranged in increasing order
of number of conditional jump \glspl{instruction}.
%
The costs range from
\printMinCycles{
  \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesAvgMin,
  \DualTargetPatternsVsBranchExtCyclesSpeedupBaselineCyclesAvgMin
} to
\printMaxCycles{
  \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesAvgMax,
  \DualTargetPatternsVsBranchExtCyclesSpeedupBaselineCyclesAvgMax
}.
%
The \gls{GMI} is \printGMI{%
  \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesRegularSpeedupGmean%
} with \gls{CI}~\printGMICI[round-precision=3]{%
  \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesRegularSpeedupCiMin%
}{%
    \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesRegularSpeedupCiMax%
}.

We see clearly that \glsshort{constraint model}~\refModel{dual-target} produces
optimal \glspl{solution} with slightly lower cost compared those produced by
\glsshort{constraint model}~\refModel{branch-ext} (up to
\printZCNorm{%
  \DualTargetPatternsVsBranchExtCyclesSpeedupCyclesZeroCenteredSpeedupMax%
} improvement).
%
Hence, in terms of code quality \glspl{DTB pattern} is a better design choice
over \gls{branch extension} when implementing insertion of jump
\glspl{instruction}.


\paragraph{Conclusions}

From the results for these experiments, we conclude that \glspl{DTB pattern} are
superior to \gls{branch extension}, both in terms of solving time and code
quality.


\section{Objective Function}
\labelSection{cm-objective-function}

During \gls{instruction selection}, most \glspl{compiler} optimize for
performance by using execution latencies of the \glspl{instruction} as
\gls{match} costs.
%
In addition, they factor in the execution frequency of the \gls{block} in which
the selected \glspl{match} are placed.
%
The intuition is that the \glspl{instruction} selected for ``hot'' \glspl{block}
-- for example, those belonging to a loop with many iterations -- will have
greater impact than those selected for scarcely executed \glspl{block}.
%
In this chapter we introduce a straightforward but naive implementation of the
\gls{objective function}, which is refined in the next chapter.


\paragraph{Variables}

The \gls{cost variable} \mbox{$\mVar{cost} \in \mathbb{N}$} models the total
cost of the selected \glspl{match}.
%
It is assumed the total cost can never be negative.


\paragraph{Constraints}

A straightforward implementation of the \gls{objective function} described above
can be modeled as
%
\begin{equation}
  \mVar{cost} =
  \sum_{\mathclap{m \in \mMatchSet}}
  \mVar{sel}[m] \times \mCost(m) \times \mFreq(\mBlockOf(m)),
  \labelEquation{naive-objective-function}
\end{equation}
%
where \mbox{$\mCost(m) \in \mNatNumSet$} denotes the cost of \gls{match}~$m$,
\mbox{$\mFreq(b) \in \mNatNumSet$} denotes the execution frequency of
\gls{block}~\mbox{$b$\hspace{-1pt},}\!%
%
\footnote{%
  In order to curb the size of the \gls{domain} of the \gls{cost variable},
  the execution frequencies must often be scaled down.
  %
  In our experiments, limiting the execution frequencies to \num{1000} proved
  sufficient.
}
%
and
%
\begin{equation}
  \mBlockOf(m)
  \equiv
  \left\{
  \begin{array}{ll}
      \mVar{oplace}[\mMin(\mCovers(m))]
    & \text{if } \mCovers(m) \neq \mEmptySet, \\
      \mVar{dplace}[\mVar{alt}[\mMin(\mDefines(m))]]
    & \text{otherwise}.
  \end{array}
  \right.
  \labelEquation{block-of-function}
\end{equation}


\section{Limitations}
\labelSection{cm-limitations}

The \gls{constraint model} described in this chapter has several limitations
that affect code quality.
%
The first limitation concerns \gls{recomputation} of values, the second concerns
\gls{if-conversion}, and the third concerns implicit sign and zero extensions
and truncations.
%
Consequently, a \gls{solution} that is considered optimal with respect to this
\glsshort{constraint model} may still be inferior to the code produced by an
\gls{instruction selector} without these limitations.


\paragraph{Recomputation}

For some combinations of \glspl{function} and \glspl{target machine}, it may be
beneficial to \glsshort!{recomputation} values appearing in common
subexpressions instead of reusing them.
%
See for example \refFigure{recomputation-example}.
%
\begin{filecontents*}{recomputation-example-ir.c}
$\irAssign{a}{x + y}$
store a, $\ldots$
$\ldots$
store a, $\ldots$
\end{filecontents*}
%
\begin{figure}
  \centering%
  \mbox{}%
  \hfill%
  \subcaptionbox{Code snippet\labelFigure{recomputation-example-ir}}%
                [25mm]%
                {%
                  \begin{lstpage}{22mm}%
                    \lstinputlisting[language=c,mathescape]%
                                    {recomputation-example-ir.c}%
                  \end{lstpage}%
                }%
  \hfill%
  \subcaptionbox{%
                  UF subgraph, covered by two matches derived from a
                  store instruction with base-plus-index addressing mode.
                  %
                  For brevity, the state nodes are not included%
                  \labelFigure{recomputation-example-graph}%
                }%
                [74mm]%
                {%
                  \input{figures/constraint-model/recomputation-example-graph}%
                }%
  \hfill%
  \mbox{}

  \caption{%
    Example illustrating when recomputation is preferred over value reuse%
  }%
  \labelFigure{recomputation-example}
\end{figure}
%
The \gls{function} performs two memory stores using the same address
value~\irVar*{a} (\refFigure{recomputation-example-ir}).
%
If the \gls{target machine} provides a memory \gls{instruction} with
base-plus-index \gls{addressing mode} (that is, the address to be used is the
sum of the values appearing in a base and an index \gls{register}), then no
add~\gls{instruction} is needed for computing~\irVar*{a}.
%
In the context of \gls{instruction selection}, this means letting the
\gls{operation} representing the addition to be covered by more than one
\gls{match} (\refFigure{recomputation-example-graph}).
%
However, \refEquationList{operation-coverage, data-definitions} require that
every \gls{operation} and \gls{datum} is covered respectively \gls{define.d}[d]
by exactly one selected \gls{match}, thus preventing such \glspl{solution}.
%
Although these \glspl{constraint} can be relaxed to allow \glspl{operation} and
\glspl{datum} to be covered respectively \gls{define.d}[d] by at least one
selected \gls{match}, many of the solving techniques introduced in this
dissertation rely on exact \gls{cover}[age].


\paragraph{If-Conversions}

In most \glspl{target machine}, performing a branch incurs a performance
penalty.
%
Some architectures therefore allow the \glspl{instruction} to be predicated with
a Boolean flag for optional execution, which allows \glspl{function} with
if-then-else structures to be transformed into linear code.
%
This process is called \gls!{if-conversion}.

Although the \gls{universal representation} enables predicated versions of the
\glspl{instruction} to be captured as \glspl{pattern}, selection of such
\glspl{pattern} is typically prevented by the \gls{constraint model}.
%
See for example \refFigure{if-conversions-example}.
%
\begin{filecontents*}{if-conversions-example-ir.c}
entry:
  $\ldots$
  if p goto body
  else goto end;
body:
  $\irAssign{a}{x + y}$
  $\irAssign{b}{v + w}$
end:
  $\ldots$
\end{filecontents*}
%
\begin{filecontents*}{if-conversions-example-instrs.c}
entry:
  $\ldots$
  if (p) add a, x, y
  if (p) add b, v, w
  $\ldots$
\end{filecontents*}
%
\begin{figure}
  \centering%
  \mbox{}%
  \hfill%
  \begin{minipage}{37mm}%
    \centering%
    \subcaptionbox{Code snippet\labelFigure{if-conversions-example-ir}}%
                  {%
                    \begin{lstpage}{30mm}%
                      \lstinputlisting[language=c,mathescape]%
                                      {if-conversions-example-ir.c}%
                    \end{lstpage}%
                  }

    \vspace{\betweensubfigures}

    \subcaptionbox{%
                    Assembly code with predicated instructions%
                    \labelFigure{if-conversions-example-instrs}%
                  }{%
                    \begin{lstpage}{37mm}%
                      \lstinputlisting[mathescape]%
                                      {if-conversions-example-instrs.c}%
                    \end{lstpage}%
                  }
  \end{minipage}%
  \hfill\hfill\hfill%
  \adjustbox{valign=M}{%
    \subcaptionbox{%
                    UF subgraph, covered by two matches derived predicated
                    add instructions%
                    \labelFigure{if-conversions-example-graph}%
                  }{%
                    \input{%
                      figures/constraint-model/if-conversions-example-graph%
                    }%
                  }%
  }%
  \hfill%
  \mbox{}

  \caption{Example of if-conversions}
  \labelFigure{if-conversions-example}
\end{figure}
%
Assume that a \gls{function} contains two sums, \irVar*{a} and~\irVar*{b}, which
are conditionally computed given a certain predicate~\irVar*{p}
(\refFigure{if-conversions-example-ir}).
%
Because this constitutes an if-then-else structure, this code snippet is
eligible for \gls{if-conversion} (\refFigure{if-conversions-example-instrs}).
%
Representing the predicated versions of add~\glspl{instruction} as
\glspl{pattern} gives rise to two \glspl{match}, $m_1$ and~$m_2$, which can
collectively cover the \glsshort{computation node} and \glspl{control node} in
the corresponding \gls{UF graph} (\refFigure{if-conversions-example-graph}).
%
However, since $m_1$ and $m_2$ both cover the same \glspl{control node}, only
one of the \glspl{match} can be selected (due to
\refEquationList{operation-coverage, data-definitions}).
%
But because both \glspl{match} \gls{consume.b} the \irBlock*{body} \gls{block},
no other \glspl{operation} may be placed in \irBlock*{body} if either is
selected (due to \refEquation{consumption}).
%
This means that either both or none of the \glspl{match} must be selected.
%
Together with the \gls{constraint} of \gls{exact.c} \gls{cover}[age], in all
\glspl{solution} neither of $m_1$ or $m_2$ is selected.
%
This problem can be fixed by relaxing the \gls{constraint} of \gls{exact.c}
\gls{cover}[age], but -- as in the case of \gls{recomputation} -- this inhibits
many of the solving techniques introduced in this dissertation.


\paragraph{Implicit Sign or Zero Extensions}

Depending on the hardware, the \gls{constraint model} may produce code with
redundant \glspl{instruction} in cases where the \gls{function} contains sign or
zero extensions.
%
See for example \refFigure{implicit-extensions-example}, which depicts a
\glsshort{UF graph}~\gls{subgraph} coverable by \glspl{match}~$m_1$, $m_2$,
and~$m_3$.
%
\begin{figure}
  \centering%
  \input{figures/constraint-model/implicit-extensions-graph}

  \caption{Example of implicit sign or zero extensions}
  \labelFigure{implicit-extensions-example}
\end{figure}
%
Assume that \irCode*{foo} represents a \gls{function} call and that \irVar*{a},
\irVar*{b}, and \irVar*{c} represent \num{8}-bit values stored in \num{32}-bit
\glspl{register}.
%
As is common, $m_3$ is derived from an \gls{instruction} that checks whether the
full contents of two \glspl{register} are equal.
%
Consequently, as a precaution the upper bytes of the \glspl{register} need to be
zero-extended (that is, those bits are all set to~\num{0}) before doing the
comparison.
%
Since nothing can be assumed about the value returned by \irCode*{foo}, this is
certainly necessary for the \gls{register} of \irVar*{a}.
%
However, it may be redundant for the register of \irVar*{b}.
%
For example, $m_2$ may be derived from a single-byte load \gls{instruction} that
clears the entire \gls{register} before loading the value.
%
But since this information is lost in the \gls{constraint model}, $m_3$ must
assume that both \glspl{register} need to be zero-extended.

One solution to this problem is to extend the \gls{pattern set} with additional
\glspl{pattern} that capture these situations.
%
For example, merging the \glspl{pattern} of $m_2$ and $m_3$ results in a
\gls{match} which, if selected, emits the \gls{instruction} of $m_2$ followed by
the \glspl{instruction} of $m_3$ without the redundant zero extension of
\irVar*{b}.
%
Depending on the \gls{instruction set}, however, this may result in an
exponential number of \glspl{pattern}.
%
If the \gls{instruction set} contains $n$~\glspl{instruction} with implicit
extensions and $m$~\glspl{instruction} that each takes $k$~values which must
first be sign- or zero-extended, then this will result in $\mBigO(n^k m)$
additional \glspl{pattern}.

Another solution is to apply the same mechanism used in \gls{copy extension}.
%
In the same manner as with \glspl{copy node}, the \gls{UF graph} is first
extended with \glspl!{extension node}.
%
Hence, for each \gls{data-flow edge}~\mbox{$\mEdge{v}{o}$\hspace{-.8pt},} where
$v$ is a \gls{value node} and $o$ is an \gls{operation}, we remove this
\gls{edge} and insert a new \gls{extension node}~\mbox{$e$\hspace{-.8pt},} a
new\gls{value node}~$v'$\!, and new \glspl{data-flow edge} such that
\mbox{$\mEdge{v}{\mEdge{e}{\mEdge{v'}{o}}}$\hspace{-.8pt}.}
%
Then the \gls{constraint model} is extended with two sets of \glspl{variable},
\mbox{$\mVar{sext}[d] \in \mSet{0, 1}$} and \mbox{$\mVar{zext}[d] \in \mSet{0,
    1}$}, denoting whether a value has been sign- respectively zero-extended.
%
We also extend the \gls{pattern set} with a special \gls!{null-extend pattern},
with \gls{graph} structure \mbox{$\mEdge{v}{\mEdge{e}{v'}}$}\!, that covers $e$
at zero cost provided that \mbox{$(\mVar{sext}[v] \mOr \mNot\mVar{sext}[v'])
  \mAnd (\mVar{zext}[v] \mOr \mNot\mVar{zext}[v'])$} holds.
%
Obviously, a \gls{match} derived from the \gls{null-extend pattern} emits
nothing if selected.
%
If the \gls{null-extend pattern} cannot be selected for covering a particular
\gls{extension node}, then this means an appropriate extension \gls{instruction}
must be emitted.


\section{Summary}
\labelSection{model-summary}

In this chapter, we have introduced a \gls{constraint model} that integrates the
problems of \gls{global.is} \gls{instruction selection}, \gls{global code
  motion}, \gls{data copying}, \gls{value reuse}, and \gls{block ordering}.
%
When multiple design choice exist for a given task, we have performed a thorough
evaluation to decide which design choice is better.
%
We have also discussed the limitations of this \glsshort{constraint model} and
how these affect the assembly code that can be produced.
%
A full implementation of the \glsshort{constraint model}, written in
\gls{MiniZinc}, is available in \refAppendix{minizinc-implementation}.
