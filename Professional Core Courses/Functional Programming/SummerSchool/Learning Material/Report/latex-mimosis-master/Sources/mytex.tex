\section{Preface}

This is a \LaTeX report written by Haodong Liao, a student of UESTC who participated the summer school of UCPH. More code of this summer school project can be seen at \href{https://github.com/Medill-East/ComputerScience/tree/master/Professional%20Core%20Courses/Functional%20Programming/SummerSchool}{MyRepository}.

\section{Introduction}

A list in F\# is an ordered, immutable series of elements of the same type\footnote[1]{https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/lists}, and some of the list funcions like map, fold and filter are very powerful for list processing. 

In this report, I replaced the library calls in \emph{myFold} and \emph{myFilter} with my own recursive implementations of these functions according to the assignment description, in detail, in both functions, I uesd \emph{match..with} to achieved pattern-matching and the idea of recrusion to implemented the functions.

All in all, results I achieved were as following:

\begin{itemize}
\item met the requirement of replacing the library calls in \emph{myFold} and \emph{myFilter} with my own recursive implementations of these functions,
\item used \emph{match..with} to achieved pattern-matching,
\item made program work by my own,
\item improved \emph{myFold} function to be more generic with the help of Prof.Sporring.
\end{itemize}

The remaining structure of the article is as follows. Section 3 states the problem in detail. Section 4 analysis and designs the problem. Section 5 describes the essential parts in my implementation. The program are evaluated in Section 6 and discussed in Section 7.

\section{Problem statement}

This assignment required us to replace the library function with recursive implementations for \emph{myFold} and \emph{myFilter} based on the file \emph{recursiveMapFoldFilter.fsx}, which is a fully functionning program must be compiled and executed from the console. 

This program takes 2 arguments: a string and a postive integer \emph{n}. The string can be either \emph{map}, \emph{fold}, or \emph{filter}. The output is a random list of length \emph{n} consisting of postive integers less than 10 and a processed list. For \emph{fold}, the random elements have been multiplied by 2 and their order have been reversed, and for \emph{filter}, only those elments larger than 4 have been included.

\section{Analysis and Design}

\subsection{Fold Function}

\lstset{language=Csh}
\begin{lstlisting}
List.fold: 
  f:('State -> 'T -> ' State) -> 
  elm:'State -> 
  lst: 'T list 
    -> ' State.
\end{lstlisting}

According to \cite{sporring2019}, List.fold function \emph{updates an accumulator iteratively by applying f to each element in lst}. 

So there were two branches needed to be handled, one is empty list, the other is list with element(s). For empty list, the return value couldn't be constrained to list and should be as same as accumulator. For list with element(s), fold function should be called recursively, the accumulator should always be the result of argument function which had parameters of accumulator and current element of list. The key part of the pseudocode is shown as following:

\begin{lstlisting}
Fold function accumulator list =
  match list with
    | emptylist -> return accumulator
    | list with element(s) -> 
        Fold function (result of function with current accumulator and element) restList
\end{lstlisting}

\subsection{Filter Function}

\lstset{language=Csh}
\begin{lstlisting}
List.filter: 
  f:('T -> bool) -> 
  lst:'T list 
    -> 'T list
\end{lstlisting}

According to \cite{sporring2019}, List.filter function \emph{returns a new list with all the elements of lst for which f evaluates to true}. 

Same as fold function, there were two branches needed to be handled. For empty list, the return value should be the empty list itself. For list with element(s), filter function should be called recursively according to the bool expression, if the value was true, not only should we call the filter function recursively, the current element should be a part of result list. If the value of bool expression is false, there was no need to care about current element.The key part of the pseudocode is shown as following:

\begin{lstlisting}
Filter boolexpression list =
  match list with
    | emptylist -> return emptylist
    | list with element(s) -> 
        if boolexpression is true
        then
          concat current element 
          and call Filter function with boolexpression and rest list
        else
          call Filter function with boolexpression and rest list  

\end{lstlisting}

\section{Program description}

\subsection{Fold function}

My implementation of fold function was as follows:

\begin{lstlisting}
let rec myFold (f: 'b -> 'a -> 'b) (acc: 'b) (lst: 'a list) : 'b =
  match lst with
    | [] -> acc
    // second time wrong
    // [] -> []
    | elm::rest -> 
        // first time wrong
        //let result = myFold f acc rest @ (f acc elm)
        //result
        let result = myFold f (f acc elm) rest
        result
\end{lstlisting}

As it shows, to my point of view, the place I made mistake was the key of this function, whether for empty list or list with element(s), a problem I met was constrained the type of return value. It was a subtle but vital problem.

\subsection{Filter function}

My implementation of filter function was as follows:


\lstset{language=Csh}
\begin{lstlisting}
let rec myFilter (p: 'a -> bool) (lst: 'a list) : 'a list =
  //List.filter p lst
  match lst with
  | [] -> []
  | elm::rest -> 
    if (p elm)
    then 
        [elm] @ (myFilter p rest)
    else 
        myFilter p rest
\end{lstlisting}

I was struggled in the code of list with element(s) when I started to solve this problem, but it was much easier when I figured out the reason confused me was that I was so obsessed with recursion and ignored the thinking of boolean expressions. Things went smoothly when I rearranged my thoughts.

\section{Evaluation}

The testing environment was macOS Mojave 10.14.5 system with iTerm and Microsoft (R) F\# Compiler version 4.1.

\subsection{Fold function}

I complied and tested the fold function with parameter \emph{fold 9}, and the result was correct:

\begin{figure}[h]
      \centering
      \includegraphics[width=\linewidth]{fold}
      \caption{Testing of fold function}
      \label{fig:fold}
\end{figure}

\subsection{Filter function}

I complied and tested the filter function with parameter \emph{filter 9}, and the result was correct:

\begin{figure}[h]
      \centering
      \includegraphics[width=\linewidth]{filter}
      \caption{Testing of filter function}
      \label{fig:filter}
\end{figure}

\section{Conclusion}

In this assignment, I implemented the \emph{myFold} and \emph{myFilter} functions with my own recursive method. I was stucked at the beginning of my writing, but things went smoothly when I rearranged my thoughts and wrote down the pseudo code. It's easy to get bogged down in the details of a program, but we should take a top-down functional programming approach and thinking more about what to do than how to do it.